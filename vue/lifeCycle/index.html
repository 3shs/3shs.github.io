<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>生命周期 | 一些零碎</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.84741abc.css" as="style"><link rel="preload" href="/assets/js/app.9047f944.js" as="script"><link rel="preload" href="/assets/js/2.3410de3c.js" as="script"><link rel="preload" href="/assets/js/20.ec6893db.js" as="script"><link rel="prefetch" href="/assets/js/10.bdbae3fc.js"><link rel="prefetch" href="/assets/js/11.bd439ed2.js"><link rel="prefetch" href="/assets/js/12.c83ea86a.js"><link rel="prefetch" href="/assets/js/13.f4613efb.js"><link rel="prefetch" href="/assets/js/14.b0c39b9a.js"><link rel="prefetch" href="/assets/js/15.45cb6731.js"><link rel="prefetch" href="/assets/js/16.bfcd93e3.js"><link rel="prefetch" href="/assets/js/17.b66fdd0f.js"><link rel="prefetch" href="/assets/js/18.69202b33.js"><link rel="prefetch" href="/assets/js/19.4a56e1ce.js"><link rel="prefetch" href="/assets/js/21.afc02202.js"><link rel="prefetch" href="/assets/js/22.36a902ec.js"><link rel="prefetch" href="/assets/js/23.bf30863b.js"><link rel="prefetch" href="/assets/js/24.16c949c5.js"><link rel="prefetch" href="/assets/js/25.3dc1aead.js"><link rel="prefetch" href="/assets/js/26.8cc16656.js"><link rel="prefetch" href="/assets/js/3.5542bbb8.js"><link rel="prefetch" href="/assets/js/4.8338fec5.js"><link rel="prefetch" href="/assets/js/5.ff064d77.js"><link rel="prefetch" href="/assets/js/6.15a0983c.js"><link rel="prefetch" href="/assets/js/7.c91364c1.js"><link rel="prefetch" href="/assets/js/8.af33230f.js"><link rel="prefetch" href="/assets/js/9.11aabaf0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.84741abc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">一些零碎</span></a> <div class="links"><!----> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript相关知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javascript/promise/" class="sidebar-link">Promise</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue相关知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/complie/" class="sidebar-link">模板解析</a></li><li><a href="/vue/genRender/" class="sidebar-link">生成render函数</a></li><li><a href="/vue/render/" class="sidebar-link">挂载渲染阶段</a></li><li><a href="/vue/update/" class="sidebar-link">更新阶段</a></li><li><a href="/vue/component/" class="sidebar-link">组件分析</a></li><li><a href="/vue/lifeCycle/" aria-current="page" class="active sidebar-link">生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/lifeCycle/#_1-前言" class="sidebar-link">1. 前言</a></li><li class="sidebar-sub-header"><a href="/vue/lifeCycle/#_2-vue生命周期" class="sidebar-link">2. vue生命周期</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack相关知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/webpack/entry/" class="sidebar-link">入口</a></li><li><a href="/webpack/optimization/" class="sidebar-link">优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络相关知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/net/http&amp;https/" class="sidebar-link">HTTP&amp;HTTPS</a></li><li><a href="/net/https/" class="sidebar-link">HTTPS</a></li><li><a href="/net/udp&amp;tcp/" class="sidebar-link">UDP&amp;TCP</a></li><li><a href="/net/tcp&amp;&amp;ip/" class="sidebar-link">TCP/IP</a></li><li><a href="/net/dns/" class="sidebar-link">DNS</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>性能相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/performance/virtualScroll/" class="sidebar-link">虚拟滚动</a></li><li><a href="/performance/cacheApi/" class="sidebar-link">接口缓存</a></li><li><a href="/performance/debounce&amp;throttle/" class="sidebar-link">防抖与节流</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>问题记录</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/workRecord/vue/" class="sidebar-link">vue相关</a></li><li><a href="/workRecord/miniprogram/" class="sidebar-link">小程序相关</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-前言"><a href="#_1-前言" class="header-anchor">#</a> 1. 前言</h2> <h2 id="_2-vue生命周期"><a href="#_2-vue生命周期" class="header-anchor">#</a> 2. vue生命周期</h2> <h3 id="init-方法-初始化"><a href="#init-方法-初始化" class="header-anchor">#</a> _init 方法 初始化</h3> <ul><li>主要是初始化 vm</li> <li>合并我们写在组件里面 options 与 vue 本身自带的 components (KeepAlive, Transition, TransitionGroup) directives(model, show) 运用策略模式 合并 赋值给 vm.$options</li> <li>然后进入 initLifecycle 方法 初始化 一些 $parent $root $children $refs _watcher _inactive _directInactive _isMounted _isDestroyed _isBeingDestroyed 赋予默认值</li> <li>然后 进入 initEvents 方法 初始化些我们写在父组件上的自定义事件 赋值给 vm._events = {}</li> <li>然后 进入 initRender 方法 初始化一些 render时候需要用到的 slots 默认值 以及 vm._c vm.$createElement</li> <li>然后 callHook 一下 beforeCreated 说明在这个钩子函数之前 我们仅仅做个一些初始化的 准备工作</li></ul> <h3 id="created-钩子执行之前阶段工作"><a href="#created-钩子执行之前阶段工作" class="header-anchor">#</a> created 钩子执行之前阶段工作</h3> <ul><li>然后进入 initInjections 方法 拿到 inject 的值</li> <li>然后进入 initState 方法</li> <li>如果又 props 调用 initProps 方法 拿到 prop 的值 并进行一些处理</li> <li>如果有方法 就调用 initMethods 方法 进行处理 包括对一些规则的校验 方法写的不对 和 props 定义重名 已_ 和 $ 开头 然后将 方法绑定到 vm上 就是 this上</li> <li>如果有data函数 调用 initData 方法 对 数据进行一些处理 包括不能和 方法重名 props 重名  最后调用 observe 这个方法 对数据进行 响应式</li> <li>如果有计算属性 调用initComputed 方法 对计算属性进行处理 然后对计算属性进行 Object.defineProperty</li> <li>如果有watch 调用 initWatch 方法 对watch 进行处理</li> <li>然后 callHook 一下 我们写在组件里的 created 钩子函数 说明当执行到这个钩子函数的时候 我们 inject props methods data computed watch 都能获取到了 而且数据都进行了 响应式</li></ul> <h3 id="beforemount-钩子执行之前阶段工作"><a href="#beforemount-钩子执行之前阶段工作" class="header-anchor">#</a> beforeMount 钩子执行之前阶段工作</h3> <ul><li>然后进入对模板的解析过程</li> <li>如果有template 就用 template 没有 就用 app 的outerHtml</li> <li>然后调用 compileToFunctions 方法 将模板编译成 render 函数 其实这里面做了很多的事情</li> <li>首先做了性能处理 这个模板如果被编译了 就从缓存里面取代</li> <li>然后进入解析我们所写的模板 调用 parse 方法 将我们所写的模板 解析成 AST 抽象语法树</li> <li>然后通过 generate 方法 生成 一个 with 函数 的字符串</li> <li>然后调用createFunction 将 witch 函数的字符串 转成 匿名函数的 witch 函数 得到 render 函数</li> <li>然后 callHook 一下 我们写在组件里的 beforeMount 这个钩子函数 说明当这个钩子函数执行的时候 我们已经将 模板编译成 render 函数了</li></ul> <h3 id="mounted-钩子执行之前阶段工作"><a href="#mounted-钩子执行之前阶段工作" class="header-anchor">#</a> mounted 钩子执行之前阶段工作</h3> <ul><li>然后进入挂载阶段</li> <li>new Watch()</li> <li>先调用 _render 方法 在这个方法里面主要是 调用我们解析好的 render 函数 生成 vnode 虚拟Dom</li> <li>然后调用 _update 方法方法</li> <li>这个方法可 update diff 算法 可第一次渲染 利用 vnde tag 的值 创建真实的 dom 挂在到 vnode ele 上 然后递归创建 最后插入到 页面中 然后删除我们原始的模板</li> <li>然后 callHoock 我们写在组件里面的 mounted 这个钩子函数 当这个钩子函数执行的时候 所有真实的dom都插入到页面中的 这是我们能获取到页面上真实的dom</li></ul> <h3 id="beforeupdate-钩子执行之前阶段工作"><a href="#beforeupdate-钩子执行之前阶段工作" class="header-anchor">#</a> beforeUpdate 钩子执行之前阶段工作</h3> <ul><li>更新阶段</li> <li>如果数据更新 利用dep.notify() 通知修改 然后找到对应的 watcher</li> <li>调用一下 watcher 上面 before 方法 这个方法 主要用来 callHook 我们写在组件里面 beforeUpdate 这个钩子函数 当执行到这个函数说明 马上就要进行数据更新 说明这时候的数据还是之前的数据</li></ul> <h3 id="updated-钩子执行之前阶段工作"><a href="#updated-钩子执行之前阶段工作" class="header-anchor">#</a> updated 钩子执行之前阶段工作</h3> <ul><li>然后重新调用 _render 函数 调用我们生成的 render 函数 重新生成一份 vnode</li> <li>然后一样调用 _update 这个方法 来进行更新 主要是diff算法 双指针的方式</li> <li>然后一个数据被多初地方用到 一定是先触发 子组件里的 update 钩子函数 然后向外 直到所有的 watcher 都被处理 意思就是 只要运用这个数据被改变了 那这个组件的 updated 钩子函数就会被触发</li> <li>当这个钩子函数执行的时候 就说明 我们可以得到最新的 数据了</li></ul> <h3 id="更新数据的主要逻辑"><a href="#更新数据的主要逻辑" class="header-anchor">#</a> 更新数据的主要逻辑</h3> <ul><li>主要逻辑 notify 通知修改</li> <li>重新调用 _render 函数 生成虚拟dom</li> <li>然后 通过 update 方法 diff 算法</li> <li>遇到子组件 patch 则调用 prepatch 方法触发更新</li> <li>子组件 通过组件的 钩子函数 prepatch 这个钩子 里面的 updateChildComponent() 方法 通过对 prop 赋值 出发 notify 去修改 为  queue 添加子组件的 watcher</li> <li></li> <li>细节 在父组件里面 更新 子组件 通过 flushing 字段 表示整个的还在更新 然后 将子组件的 这个 watcher 加到 queue 后面</li> <li>然后继续循环 queue 队列 这时候 队列里有个 子组件 watcher</li> <li>然后开始更新 同样 render函数 update方法 diff 去修改模板</li> <li></li> <li></li> <li></li> <li></li> <li>new Watcher 将 render 函数传进去  render 对应 Wacther 调用 watcher 的 get 方法其实就是 调用 render</li> <li>这是将 Dep.target = this(对应这个Watcher)  dep.depend 就将这个 watcher 收集进去</li></ul> <h3 id="slot-解析-先解析-父组件么"><a href="#slot-解析-先解析-父组件么" class="header-anchor">#</a> slot 解析 先解析 父组件么？</h3> <ul><li>当解析到父组件的 slot=header 就给 ast 加上 slotTarget 属性 el.slotTarget = &quot;header&quot;</li> <li>然后在生成 render 函数的处理 el.slotTarget</li> <li>生成例如 _c('div', {attr: &quot;slot&quot;: &quot;header&quot;}, slot: &quot;header&quot;)</li> <li>到这里父组件关于插槽的就解析好了</li> <li></li> <li>在父组件里生成子组件的dom 我们写的不是 标准标签 是作为一个vnode来生成的</li> <li>但是这个 vnode 有个特殊之处 就是在于 他提供一个 componentOptions 这个属性 值为</li> <li>{</li> <li>Ctor: 构造子类的构造函数 其实就是 _init 重新走一遍</li> <li>children: [] 子组件在父组件中使用 在标签内定义的一些 插槽 内容</li> <li>listeners：事件</li> <li>propsData: props 对象 {name : 'zs'}</li> <li>tag: 'child'</li> <li>}</li> <li></li> <li></li> <li>然后在生成真实的dom的时候 继续处理 component 处理</li> <li>如果发现这个标签是组件标签 就再对组件进行处理 用提供的组件钩子函数进行处理 init prepatch insert 等等</li> <li>拿到之前的 Ctor 拿到父级作用域 然后是 本身的虚拟dom</li> <li>options:{</li> <li>_isComponent: true,
_parentVnode: vnode,
parent: parent</li> <li>}</li> <li>new vnode.componentOptions.Ctor(options)</li> <li>然后进入 _init方法</li> <li>如果是组件则进入 initInternalComponent 方法 对 option 进行处理</li> <li>处理成</li> <li>vm.options: {</li> <li>parent,</li> <li>propsData,</li> <li>_componentTag,</li> <li>_parentListeners,</li> <li>_parentVnode vnode 对应组件本身</li> <li>_renderChildren vnode  对应 在父组件内 引入 子组件 在子组件内写的 插槽内容</li> <li>}</li> <li></li> <li>然后再initRender 里面 对插槽进行数据处理 最终修改成 下面的形式</li> <li>vm.$slot: {</li> <li>header: [vnode]</li> <li>default: [vnode]</li> <li>footer: [vnode]</li> <li>}</li> <li></li> <li>然后进入解析阶段</li> <li>同样解析 将 template 里的模板变成 render 函数</li> <li>有 slot 标签 最后都会 转成 _t(&quot;header&quot;) _t(&quot;default&quot;) _t(&quot;footer&quot;)</li> <li>然后在挂载阶段对slot进行出里 转换成</li> <li>{</li> <li>header: function () { return slot[key] } slot 对应前面解析出来的 $slot key 对应就是 header</li> <li>}</li> <li>然后执行 render 函数 _t 调用 renderSlot 方法 里面就调用 之前的 function () { return slot[key] } 取出对应的 vnode</li> <li></li> <li>整体逻辑就是 在父组件 解析到组件 比如 上文的 child</li> <li>然后vue 发现他是一个组件 然后将这个组件 特殊处理 生成 组件 vnode 时候 会定义 一个 componentOptions 这个属性</li> <li>属性值为</li> <li>{</li> <li>Ctor: 构造子类的构造函数 其实就是 _init 重新走一遍</li> <li>children: [] 子组件在父组件中使用 在标签内定义的一些 插槽 内容</li> <li>listeners：事件</li> <li>propsData: props 对象 {name : 'zs'}</li> <li>tag: 'child'</li> <li>}</li> <li>然后解析组件的时候 处理 插槽 对应的那个 vnode</li> <li>然后在 调用子组件的时候 传入 slot 的 值 返回对应的 vnode</li> <li>子组件内的 vnode 全都转成真实的 dom 插入到 父组件中</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue/component/" class="prev">
        组件分析
      </a></span> <span class="next"><a href="/webpack/entry/">
        入口
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9047f944.js" defer></script><script src="/assets/js/2.3410de3c.js" defer></script><script src="/assets/js/20.ec6893db.js" defer></script>
  </body>
</html>
