(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{276:function(_,v,t){"use strict";t.r(v);var e=t(13),s=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-什么是ssl-tls"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是ssl-tls"}},[_._v("#")]),_._v(" 1. 什么是SSL/TLS")]),_._v(" "),v("p",[v("code",[_._v("SSL")]),_._v(" （Secure Sockets Layer 安全套接字协议）还有继任者 "),v("code",[_._v("TLS")]),_._v("（Transport Layer Security 传输层安全）是为网络通信提供安全及数据完整性的一种安全协议")]),_._v(" "),v("h2",{attrs:{id:"_2-ssl如何做到安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-ssl如何做到安全"}},[_._v("#")]),_._v(" 2. SSL如何做到安全")]),_._v(" "),v("p",[v("code",[_._v("SSL")]),_._v(" 实现这些功能主要依赖于三种手段")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("对称加密")]),_._v(" 采用协商的密钥对数据加密")]),_._v(" "),v("li",[v("code",[_._v("非对称加密")]),_._v(" 实现身份认证和密钥协商")]),_._v(" "),v("li",[v("code",[_._v("摘要算法")]),_._v(" 验证信息的完整性")]),_._v(" "),v("li",[v("code",[_._v("数字签名")]),_._v(" 身份验证")])]),_._v(" "),v("h3",{attrs:{id:"_2-1-对称加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-对称加密"}},[_._v("#")]),_._v(" 2.1 对称加密")]),_._v(" "),v("p",[_._v("对称加密 是加密和解密使用的密钥的都是同一个 是对称的 只要保证了密钥的安全 那整个通信过程就可以说具有了机密性")]),_._v(" "),v("p",[_._v("明文 ---\x3e 通过对称密钥加密 ---\x3e  密文 ---\x3e 通过对称密钥解密 ---\x3e 明文")]),_._v(" "),v("h3",{attrs:{id:"_2-2-非对称加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-非对称加密"}},[_._v("#")]),_._v(" 2.2 非对称加密")]),_._v(" "),v("p",[_._v("非对称加密 存在两个密钥 一个叫公钥 一个叫私钥 两个密钥不同 公钥可以公开给任何人使用 私钥则需要保密")]),_._v(" "),v("p",[_._v("公钥和私钥都可以用来加密和解密 但公钥加密后只能用私钥解密 反过来 私钥加密后也只能用公钥解密")]),_._v(" "),v("p",[_._v("明文 ---\x3e 通过公钥加密 ---\x3e  密文 ---\x3e 通过私钥解密 ---\x3e 明文")]),_._v(" "),v("h3",{attrs:{id:"_2-3-混合加密"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-混合加密"}},[_._v("#")]),_._v(" 2.3 混合加密")]),_._v(" "),v("p",[_._v("在 "),v("code",[_._v("HTTPS")]),_._v(" 通信过程中 采用的是 对称加密 + 非对称加密 也就是混合加密")]),_._v(" "),v("ol",[v("li",[_._v("浏览器使用服务器的公钥 来加密要传送的 "),v("code",[_._v("对称加密的密钥")])]),_._v(" "),v("li",[_._v("服务器收到加密后的 "),v("code",[_._v("对称加密的密钥")]),_._v(" 使用自己的私钥进行解密 就可以获得该 "),v("code",[_._v("对称加密的密钥")])])]),_._v(" "),v("p",[_._v("这样通过非对称加密保证了密钥的安全交换 服务器和客户端可以使用这个对称密钥开始安全的对称加密通信")]),_._v(" "),v("h3",{attrs:{id:"_2-4-摘要算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-摘要算法"}},[_._v("#")]),_._v(" 2.4 摘要算法")]),_._v(" "),v("p",[_._v("摘要算法 可以理解成一种特殊的压缩算法 它能够把任意长度的数据 "),v("code",[_._v("压缩")]),_._v(" 成固定长度 而且独一无二的 "),v("code",[_._v("摘要")]),_._v(" 字符串 就好像是给这段数据生成了一个数字 "),v("code",[_._v("指纹")])]),_._v(" "),v("p",[_._v("摘要算法保证了 "),v("code",[_._v("数字摘要")]),_._v(" 和原文是完全等价的 所以 我们只要在原文后面附上它的摘要 就能保证数据的完整性")]),_._v(" "),v("p",[_._v("明文 + 摘要（9e13f543efsdf52r） ---\x3e 通过会话密钥加密 ---\x3e 密文 ---\x3e 通过会话密钥解密 ---\x3e 明文 + 摘要（9e13f543efsdf52r）服务端用 SHA-2 生成的 摘要 （9e13f543efsdf52r） 做对比")]),_._v(" "),v("h3",{attrs:{id:"_2-5-数字签名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-数字签名"}},[_._v("#")]),_._v(" 2.5 数字签名")]),_._v(" "),v("p",[_._v("数字签名 主要用于验证证书的可靠性和真实性")]),_._v(" "),v("ol",[v("li",[_._v("数字签名的生成")])]),_._v(" "),v("ul",[v("li",[_._v("证书颁发机构（CA）收集证书信息 使用散列函数生成证书内容的信息摘要")]),_._v(" "),v("li",[_._v("CA使用自己的私钥对这个信息摘要进行加密 形成数字签名")])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[_._v("数字签名在证书中的包含")])]),_._v(" "),v("ul",[v("li",[_._v("数字签名会包含在SSL证书文件中 以证明证书内容的真实可靠")])]),_._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[_._v("数字签名的认证")])]),_._v(" "),v("ul",[v("li",[_._v("用户获取证书时 先通过CA的公钥解密数字签名 获取原始摘要")]),_._v(" "),v("li",[_._v("用户使用同样的散列函数计算证书内容的摘要")]),_._v(" "),v("li",[_._v("比较两个摘要 如果一致 则证明证书来自该CA 内容完整可信")])]),_._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[_._v("验证CA的可靠性")])]),_._v(" "),v("ul",[v("li",[_._v("用户可以通过预置的可信CA根证书 验证颁发机构的签名是否可靠")])])])}),[],!1,null,null,null);v.default=s.exports}}]);